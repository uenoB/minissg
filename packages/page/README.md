# @minissg/page

This library provides a feature to manage the set of webpages to be
generated by [Minissg].

## Install

Install the package by

```bash
npm install @minissg/page
```

and import it in the root file of your project as follows:

```js
import { Page } from "@minissg/page"
```

or

```js
import Page from "@minissg/page"
```

## Basic Usage

Each instance of the `Page` class represents a webpage to be generated
by a JS module.
The typical usage of the `Page` class is as follows:

1. Create the root `Page` with `import.meta.url` and website's URL.

   ```javascript
   const root = new Page({ fileName: import.meta.url, url: "https://example.com" });
   ```

2. Bind modules to the root page with `import.meta.glob`.

  ```javascript
  page.bind(import.meta.glob("./page/**/*.js"), "./page/");
  ```

  This adds all JS files matched with `./page/**/*.js` to the website
  as webpages of URL `**/*/`.
  For example, when `url` of `root` is `https://example.com/foo/`,
  `./page/bar/baz.js` is added to `root` as `https://example.com/foo/bar/baz`
  with the content of its `default` export.
  The second argument `"./page"` means the common prefix of file names
  that should be eliminated before computing their corresponding URLs.

  If a file name has additional extensions, the sequence of them is
  interpreted as an identifier of variation of a webpage.
  For example, `./page/bar/baz.en.js` and `./page/bar/baz.ja.js` are
  recognized as `en` and `ja` variants of `bar/baz`, respectively.
  Actually, `./page/bar/baz.js` is also a variant of `bar/baz` identified
  with an empty string.

  If a file name contains `..`, the part before `..` is used as its URL.
  This avoids extensions to be recognized as variant identifier.
  For example, the URL of `./page/index.html..js` is `index.html`,
  which is interpreted as `/` by Minissg.

3. Export the root page through `entries`:

  ```javascript
  export entries = () => root;
  ```

  Then, Minissg recognizes all the pages added to `root`.

### Render Objects as Webpages

A page module must be a Module of Minissg but may have `default` of
arbitrary type.
To have `default` of some type that Minissg cannot accept, override
`render` method by making a subclass of `Page`.
For example, to use Preact to write the contents, define the following
class in some `.jsx` file and use it instead of using `Page` directly:

```javascript
import render from "virtual:minissg/self?renderer";
import Page from "@minissg/page";

class PreactPage extends Page {
  render({ default }) {
    return render(default)
  }
}
```

In TypeScript:

```javascript
import render from "virtual:minissg/self?renderer";
import Page from "@minissg/page";

class PreactPage extends Page<{ default: preact.ComponentType }> {
  render({ default }: { default: preact.ComponentType }) {
    return render(default)
  }
}
```

### Link to Other Pages

The `find` method allows you to search for a page by relative path of
either URL or file name.
Pass the page object to a component as follows:

```javascript
render(module) {
  return render(() => <module.default page={this} />)
}
```

and use it like this:

```javascript
const Anchor = ({ page, href, children }) => (
  <a href={page.find(href) ?? href}>{children}</a>
)

export default ({ page }) => (
  <Anchor page={page} href="./baz.js">link to ../baz/</a>
)
```

## Customization

You are allowed to define a subclass of `Page` and override the
constructor, `parsePath`, and `render` to change the behavior.

```typescript
import { type Source, type PathInfo, Page } from '@minissg/page'

class YourPage extends Page<YourModule> {
  // put your own properties here

  constructor(src: Source) {
    super(src)
    // put your initialization code here
  }

  override parsePath(path: string): PathInfo {
    // put your file path interpretation here
  }

  override render(module: YourModule): Content | PromiseLike<Content> {
    // put how to render your module here
  }
}
```

## Reference

### `PathInfo` Type

```typescript
interface PathInfo {
  stem: string
  variant: string
  relURL: string
}
```

### `Source` Type

```typescript
interface Source {
  fileName: URL | string
  url: URL | string
  stem?: string | undefined
  variant?: string | undefined
}
```

### `Page` Class

```typescript
class Page<ModuleType = unknown> {
  constructor(src: Source);
  bind(pages: Iterable<readonly [string, () => (ModuleType | PromiseLike<ModuleType>)]>, prefix: string = ''): this;
  bind(pages: Record<string, () => (ModuleType | PromiseLike<ModuleType>)>, prefix: string = ''): this;
  mkdir(path: string): this;
  mount(page: this): this;
  findByFileName(path: string): this | undefined;
  findByURL(path: string): this | undefined;
  find(path: string): this | undefined;
  variants(): ReadonlyMap<string, this>;
  load(): PromiseLike<ModuleType> | undefined;
  parsePath(path: string): PathInfo; // can be overriden
  render(module: YourModule): Content | PromiseLike<Content>; // can be overriden
  entries: Entries
}
```

## License

MIT

[Minissg]: https://github.com/uenoB/vite-plugin-minissg
